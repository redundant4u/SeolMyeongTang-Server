{
  "seolmyeongtang": [
    {
      "PutRequest": {
        "Item": {
          "PK": {
            "S": "post"
          },
          "SK": {
            "S": "test3"
          },
          "Content": {
            "S": "hello\n\n`Hello`\n\n*hello*\n\nhello\n\n~~hello~~\n\n**hello**\n\n```\nHello\n```\n\n- hello\n    - hello\n        - hello\n1. hello\n2. hello\n3. hello\n\n| hello | hello |\n| --- | --- |\n| hello | hello |\n| hello | hello |\n\n$$\nx^2=hello\n$$"
          },
          "CreatedAt": {
            "S": "2023-05-20"
          },
          "Title": {
            "S": "test3"
          }
        }
      }
    },
    {
      "PutRequest": {
        "Item": {
          "PK": {
            "S": "post"
          },
          "SK": {
            "S": "test4"
          },
          "Content": {
            "S": "hello\n\n`Hello`\n\n*hello*\n\nhello\n\n~~hello~~\n\n**hello**\n\n```\nHello\n```\n\n- hello\n    - hello\n        - hello\n1. hello\n2. hello\n3. hello\n\n| hello | hello |\n| --- | --- |\n| hello | hello |\n| hello | hello |\n\n$$\nx^2=hello\n$$"
          },
          "CreatedAt": {
            "S": "2023-04-11"
          },
          "Title": {
            "S": "longgggggtexxxxttttttttt123213"
          }
        }
      }
    },
    {
      "PutRequest": {
        "Item": {
          "PK": {
            "S": "post"
          },
          "SK": {
            "S": "serverless_cloudfront"
          },
          "Content": {
            "S": "[이전 글](https://redundant4u.com/post/serverless_lambda)에서 서버리스 이전을 위해 다음의 일을 진행했습니다.\n\n1. 기존에 쓰고 있었던 Notion API 제거\n2. DynamoDB 설계\n3. 프론트 렌더링 방식 변경(Notion API → md 렌더링)\n4. Lambda 생성\n5. API Gateway 생성 및 Lambda 연결\n\n백엔드 쪽 부분을 만들고 배포까지 하였으니 이제 프론트 배포만 남았습니다. 프론트 배포를 위해 S3와 CloudFront를 사용할 겁니다. 기존 프론트 배포는 Nginx를 이용했습니다. Nginx 컨테이너에 배포할 프론트 정적 파일들을 두고 Nginx가 서비스하는 형태였습니다. 기존의 형태를 대입해보면, **S3가 정적 파일들을 보관하고 CloudFront가 Nginx의 웹 서버 역할과 캐싱 기능까지 수행한다고 생각하면 될 거 같습니다.**\n\n설명탕의 프론트는 NextJS로 작성되어 있으며, [SSR(Server-side Rendering)](https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering)은 사용하지 않고 [SSG(Static Site Generation)](https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation) 기능만 사용합니다. 전 시간에 서버 배포 작업을 하면서 변경된 API 주소를 넣고, NextJS 빌드 후 나온 정적 파일들을 S3에 업로드합니다. 마지막으로 S3와 CloudFront를 연동만 하면 배포가 됩니다. CloudFront 배포는 여러 블로그에서 자세하게 설명한 것을 참고하면 좋을 거 같아 이 부분은 생략하겠습니다. 제가 추가적으로 따로 설정한 것은 S3와 직접적인 통신을 막기 위한 ‘원본 엑세스(OAI)’와 ‘대체 도메인 이름’ 설정입니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230509/1.jpg\" alt=\"설명탕 서버리스 구조도\" /><figcaption>설명탕 서버리스 구조도</figcaption></figure>\n\n드디어 기존 EC2에서 Lambda, API Gateway, S3, CloudFront를 이용한 서버리스 환경 구축을 완료하였습니다. 감격의 눈물을 쏟으려는데… 어? 뭔가 이상합니다. Dynamic route 페이지에 대한 새로고침이 되지 않았습니다. **정확히는 게시글 페이지에서 새로고침을 하면 403 에러(Access Denied)가 나타났습니다.**\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230509/2.png\" alt=\"ugh?\" /><figcaption>어?</figcaption></figure>\n\n여러 추측과 원인을 분석해본 결과, 설명탕 URL은 `redundant4u.com/post/cpu` 이런 식으로 맨 뒤에 `cpu`와 같이 dynamic route 값이 붙습니다. 이 페이지에서 새로고침을 하게 되면 S3에서 `cpu` 이름을 가진 파일을 찾습니다. NextJS를 빌드하면 `cpu`가 아닌 `cpu.html` 파일을 생성하므로 `cpu`는 찾을 수 없는 파일로 인식하여 403을 뜬다는 사실을 알았습니다.\n\n기존에는 Nginx에서 프론트 정적 파일들을 서비스 했습니다. 그리고 NextJS를 빌드 할 때 `trailingSlash` 옵션을 주어 dynamic route 값 이름으로 디렉터리를 만들고 그 안에 `index.html` 파일이 생성하도록 구성했습니다(trailingSlash 옵션을 주지 않으면 `[dynamic route 값].html` 형식으로 파일이 생성됩니다). Nginx의 설정 파일에서 `try_files` 옵션으로 `${postId}.html`와 같은 형식으로 지정할 수 있어 해당 오류가 발생하지 않았습니다.\n\n```\ntry_files $uri $uri.html $uri/ /index.html;\n```\n\n**여러 고민 끝에 해결한 방법은 html 확장자를 떼어버렸습니다.** 처음에 이 방법을 도입하려 했을 때, 돌아가기 위해 욱여넣는 느낌이 강해서 이게 맞나 싶었습니다. Lambda Edge를 통해 해결하기, NextJS 설정 건드리기 등등의 방법을 생각해봤는데 최종적으로 html 확장자를 없애는 방법이 가장 깔끔하다고 판단했습니다. 프론트 배포할 때 빌드 후 스크립트를 통해 html 확장자를 없앤 뒤 S3에 업로드 하도록 CICD를 구성했습니다. 여기서 주의할 점은 html 확장자를 없앤 파일을 그대로 S3로 업로드하면 binary 파일로 인식합니다. 이를 방지하기 위해 html이라는 메타데이터를 설정해주기 위해 aws s3 cli의 `--content-type` 옵션으로 `text/html`을 지정해줘야합니다. 마지막으로 CloudFront 캐싱 무효화 처리까지 해주면 배포가 완료됩니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230509/3.png\" alt=\"text/html 메타데이터를 지정해주지 않으면, 확장자가 없으므로 binary로 인식한다\" /><figcaption>text/html 메타데이터를 지정해주지 않으면, 확장자가 없으므로 binary로 인식한다</figcaption></figure>\n\n```yaml\n- name: Build\n  run: yarn build\n\n- name: Compress\n  run: tar -zcf ${GITHUB_SHA::8}.tar.gz out\n\n- name: Delete html extension\n  run: |\n      for file in $(find ./out -name \"*.html\"); do mv \"$file\" \"${file%%.html}\"; done\n      mv out/index out/index.html\n\n- name: Upload to S3\n  run: |\n      aws s3 mv --region ap-northeast-2 \\\n        ${GITHUB_SHA::8}.tar.gz \\\n        ${{ secrets.S3_CLIENT_LOCATION }}/${GITHUB_SHA::8}.tar.gz\n\n- name: Sync S3\n  run: |\n      aws s3 sync out ${{ secrets.S3_CLIENT_DEPLOYMENT }} \\\n        --exclude \"*.*\" \\\n        --content-type \"text/html\" \\\n        --delete\n      aws s3 sync out ${{ secrets.S3_CLIENT_DEPLOYMENT }} \\\n      --exclude \"*\" \\\n      --include \"*.png\" --include \"*.jpeg\" --include \"*.json\" --include \"*.js\" --include \"*.css\" --include \"*.ico\" --include \"*.html\" \\\n      --delete\n\n- name: Invalidate CloudFront Cache\n  run: |\n      aws cloudfront create-invalidation \\\n      --distribution-id ${{ secrets.AWS_DISTRIBUTION_ID }} \\\n      --paths \"/*\"\n```\n\n이렇게 해서 드디어 설명탕은 서버리스 환경으로 이전을 하였습니다. 서버리스 개념이 익숙하지 않고 까다로운 부분들이 많아서 도중에 ‘기존에 잘 돌아가는 서버 엎고 무슨 부귀영화를 누리겠다고… 이게 무슨 짓이지’ 와 같은 고민을 했습니다. 막상 다 구축하고 나서 고생한 만큼 큰 장점이 보이지 않아(?) 조금은 허무하기도 한 거 같습니다.\n\n이번 경험을 통해 서버리스를 구축하면서 다음과 같은 생각을 해서 좋았습니다.\n\n1. AWS CLI와 쉘 스크립트의 힘은 대단하다\n2. 데이터가 작은(혹은 트래픽이 낮은) 서비스는 Lambda로도 충분할 거 같다(cold start의 문제점을 느끼지 못했다)\n3. API Gateway 관리가 편하다(특히 배포 부분)\n4. ‘효율적인 NoSQL 설계란 무엇인가’를 생각해서 좋았다\n5. ~~망할 NextJS~~\n\n그리고 이전의 환경과 비교하여 다음과 같은 효과를 얻을 수 있었습니다.\n\n1. API 호출 속도 개선\n    - 대략 1000ms → 60ms\n    - Cold start 일 때, 대략 600ms 정도로 이전과 비슷\n2. API 데이터 크기 최소화\n    - 홈화면 글 데이터 조회 시 대략 데이터 크기 50% 감소\n    - 통신하는데 불필요한 데이터 삭제\n3. 요금 문제\n    - EC2에서 서버리스로 옮기면서 한 달에 치킨 한 마리 값 정도 절약\n\n하지만 여전히 서버리스에 대하여 의문점과 구현해보고 싶은 것들이 있습니다.\n\n1. 서버리스에서 SSR 운영은 어떻게 해야하나?\n    - Lambda Edge로 한다고 하던데 어떻게 하는거지?\n2. 서버리스 자동 배포 구성은 어떻게 해야하나?\n    - AWS CLI와 쉘 스크립트로 아름답게 작성할 수 있을 거 같다\n    - Lambda 함수 생성 혹은 업데이트 → API Gateway 연결 → API Gateway 배포\n3. 로직이 복잡한 백엔드를 어떻게 서버리스에 올리지?\n    - 로직이 복잡해도 결합도가 낮다면 가능할지도?\n4. API Gateway로 인증 관리를 경험해 보고 싶다\n5. 로컬에서 서버리스 테스트는 어떻게 해야하나?\n    - [serverless-offline](https://www.serverless.com/plugins/serverless-offline)와 같은 물건이 있다\n\n이번에 구축한 서버리스는 HTTP 통신을 하는 서비스만 이전했습니다. 웹소켓 통신하여 웹 터미널을 띄우는 [설명탕의 자기소개 페이지](https://redundant4u.com/about)에는 기존의 EC2와 통신합니다. 사실 EC2를 1년 예약 인스턴스를 구입해서 남는 EC2 자원을 쓰는 겸 해서 웹소켓 통신 부분은 천천히 서버리스로 옮길려고 합니다. 기회가 된다면 웹소켓 서버리스 이전도 정리하면 좋을 거 같습니다.\n\n서버 비용으로 고생하고 있거나 운영하고 있는 서비스 규모가 작다면 서버리스 도입을 추천드리고 싶습니다. 하지만 서비스 안정성 추구, 대규모 트래픽이 발생하는 서비스는 서버리스보다 EC2와 같은 24시간 대기 서버가 효율이 더 좋다고 판단되니 상황에 따라 선택하면 될 거 같습니다.\n\n_23.05.13 추가_\n\nTrailing slash 옵션 해제로 `https://redundant4u.com/post/${postId}/`와 같이 맨 끝에 `/`로 끝나면 403 에러가 떴습니다. `${postId}/`로 끝나면 `/`를 지워서 `${postId}` 리다이렉트 하도록 구성하고 싶었습니다. 이를 구현하기 위해 Lambda Edge를 만들었습니다. Lambda Edge는 CloudFront 기능 중 하나로, 사용자의 요청(viewer request, origin request)과 응답(viewer response, origin response)을 코드를 통해 조절, 관리할 수 있습니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230509/4.jpg\" alt=\"Lambda Edge를 통해 request와 response를 관리할 수 있다\" /><figcaption>Lambda Edge를 통해 request와 response를 관리할 수 있다</figcaption></figure>\n\n사용자의 요청이 CloudFront로 가기전에(viewer request) URL를 검사하고 맨 끝에 `/`가 존재한다면 `/`를 삭제하는 로직을 Lambda Edge에 써주면 됩니다. 직접 구현하려다가 [LambdaEdgeRemoveTrailingSlash](https://serverlessrepo.aws.amazon.com/applications/arn:aws:serverlessrepo:us-east-1:951661612909:applications~LambdaEdgeRemoveTrailingSlash)라는 템플릿이 발견하고 적용했습니다.\n\n설치 과정을 참고하면 쉽게 Lambda Edge를 구축할 수 있습니다. 다만 주의할 점이 Lambda Function을 만들 때 버지니아 북부(us-east-1)로 생성해야 CloudFront와 연동할 수 있으니 이 점 주의해야합니다. Lambda Edge와 CloudFront를 연동하면 자동으로 CloudFront가 배포가 진행됩니다.\n\n배포까지 마쳤다면, URL이 `/`로 끝나면 `/`를 지우고 리다이렉트하는 모습을 볼 수 있습니다."
          },
          "CreatedAt": {
            "S": "2023-05-09"
          },
          "Title": {
            "S": "싱글벙글 서버리스 이전 삽질기(w. CloudFront)"
          }
        }
      }
    },
    {
      "PutRequest": {
        "Item": {
          "PK": {
            "S": "post"
          },
          "SK": {
            "S": "serverless_lambda"
          },
          "Content": {
            "S": "2023년 1월, Notion(이하 노션)에서만 끄적끄적 글을 썼었는데 이걸 개인 블로그로 운영하면 재미있을거 같다는 생각으로 설명탕을 만들었습니다. 설명탕을 만든 이유 중 하나는 개발부터 배포까지 제가 가지고 있는 모든 지식을 총동원하여 서비스 형태로 풀어보고 싶었기 때문입니다. 그중 인프라는 전통적인 방식이라 할 수 있는, 24시간 돌아가는 서버 위에 도커를 띄워서 프론트엔드, 백엔드 서비스를 돌렸습니다. 자동 배포 시스템도 구축하고 [자기소개 페이지도 만들고](https://redundant4u.com/post/webterminal_about_me) 개인 블로그를 운영하기에 더할 나위 없이 좋았습니다. **하지만 아쉬운 점이 있다면 서버 고정 비용과 노션 api 응답이 느렸다는 점입니다.**\n\n개인 블로그 수준에서는 트래픽이 많지 않아 24시간 돌아가는 서버는 사치입니다. 설명탕 홈페이지 같은 경우는 AWS의 EC2 t3.micro 사양을 사용하고, 예약 인스턴스 1년 형태로 구매하여 한 달에 1만원 정도의 요금을 내고 있습니다. 서버 비용으로 한 달에 1만원이면 크지 않지만 줄일 수만 있다면 줄이고 싶은 비용입니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230502/1.png\" alt=\"1만원도 돈이야 돈!\" /><figcaption>1만원도 돈이야 돈!</figcaption></figure>\n\n글 내용 정보 같은 경우는 먼저 노션에 글 초안과 퇴고를 거쳐 글을 완성합니다. 그리고 백엔드에서 Notion API를 통해 글 데이터를 가져오고 프론트엔드에 필요한 내용만 가공해서 던져주는 방식으로 구성했습니다. 이 방식은 Notion API에 의존적입니다. 안타깝게도 Notion API을 통해 글 30개 정도를 불러오는 응답 속도가 평균적으로 2초 정도로 느립니다. [react-query](https://github.com/TanStack/query)에서 `initialData` 옵션으로 글을 빠르게 불러올 수 있지만 **근본적으로 Notion API의 응답 속도를 컨트롤 할 수 없었습니다.**\n\n```tsx\nconst Body = ({ database }: PropTypes) => {\n\tconst { data } = useQuery('notion', getDatabase, {\n\t\tinitialData: database,\n\t});\n\t...\n};\n\nexport default Body;\n```\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230502/2.png\" alt=\"로컬 환경에서 Notion API 속도 측정\" /><figcaption>로컬 환경에서 Notion API 속도 측정</figcaption></figure>\n\n이러한 문제를 해결하기 위해 서버리스 형태를 고민했습니다. 서버리스는 EC2와 달리, 서버를 대여하여 사용한 시간만큼 비용을 지불하는 형식이 아니라 사용자가 서버리스를 호출하는 만큼의 비용만 지불하면 되는 형태입니다. 서버리스를 구축하기 위해 AWS의 Lambda, API Gateway, Cloudfront, S3, DynamoDB 제품을 사용했습니다. 제가 계산해본 비용은 달에 몇 천원대로 나오는데 이 제품들의 정확한 비용을 알고 싶으면 [AWS 계산기](https://calculator.aws/#/addService)를 활용하면 좋을거 같습니다. 또한 Notion API 대신 DynamoDB에 데이터를 저장하고 Lambda를 통해 데이터를 가져오는 형식으로 Notion API를 대체하는 것으로 결정했습니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230502/3.jpg\" alt=\"서버리스 이전 구조도와 서비리스 구조도\" /><figcaption>서버리스 이전 구조도와 서비리스 구조도</figcaption></figure>\n\n개인 블로그를 운영하는데 전혀 문제 없었던 서버이지만 예전부터 서버리스로 서비스를 구성해보고 싶었고 이참에 비용도 줄일 겸 기존 EC2 대신 서버리스로 옮기는 작업을 진행했습니다. 실전 프로덕션도 아닌 개인 블로그인데 해보고 싶은걸 적용하고 삽질하는게 낭만 아닐까요 😎\n\n이전부터 개인 블로그에 서버리스를 도입하고 싶었지만, 서버리스에 대한 의문점들이 많았습니다. 서버가 없다면 인증 관리는 어떻게 하는 거지? 자동배포는 어떻게 하는 거지? Cold start 때문에 응답 속도가 느리다는데 성능이 괜찮을까? 복잡한 로직을 서버리스에 올릴 수 있을까? 하는 서버리스에 대한 회의적인 시선이 있어 쉽게 선택하기 어려웠습니다. 설명탕은 글 내용 조회만 하는 단순한 구조라서 인증 관리나 복잡한 DB 쿼리를 날리거나 하지는 않아 서버리스를 구축하면서 서버리스에 궁금했던 모든 질문에 답을 내리지 못했습니다. 생각의 흐름 순서로 작성하여 다소 글이 깔끔하지 못하고 장황할 수 있지만 서버리스를 구축하면서 어떤 점이 좋았고 어떤 점이 불편했는지 저의 경험을 공유하고자 글을 정리하게 되었습니다.\n\n서버리스로 옮기기 위해 가장 처음으로 한 일은 Notion API 제거였습니다. Notion API를 제거함으로써 프론트엔드, 백엔드, 인프라 모든 부분이 바뀌어졌습니다. 노션에 쓰인 글들은 마크다운 형식으로 가져올 수 있습니다. Notion API를 통해 글 데이터를 가져오지 말고, 노션 글을 마크다운으로 가져오고 이걸 어딘가에 저장하고 서버를 통해 다시 가져오는 방법으로 생각했습니다. 데이터를 저장해야 하니 DB가 필요했습니다. 평소 같으면 RDS는 비용 문제로 사용하지 않고 EC2에 DB 컨테이너를 띄웠을 겁니다. 하지만 서버리스와 통신해야 하고 예상되는 DB 구조가 복잡하지 않아 NoSQL 종류인 DynamoDB를 선택했습니다.\n\n그 다음으로 DynamoDB를 설계해야했는데 이 부분이 RDBMS이랑 방법이 달라서 헤맸습니다. DB 테이블의 키 이름 컨벤션은 PascalCase로 통일했습니다. DynamoDB에서 PK를 테이블 같은 느낌으로 SK를 id 같은 느낌으로 생각하였습니다. 그리고 글 제목, 글 내용, 글 생성 날짜를 담을 `Title`, `Content`, `CreatedAt` 키를 추가했습니다.\n\n| PK   | SK                 | Title                           | Content   | CreatedAt  |\n| ---- | ------------------ | ------------------------------- | --------- | ---------- |\n| post | mdn_autocompletion | MDN의 자동완성 검색 이야기      | (md 형식) | 2021-08-12 |\n| post | qemu_kvm           | QEMU, KVM, QEMU-KVM가 뭐야?     | (md 형식) | 2021-08-18 |\n| post | webassembly        | 웹과 시스템의 만남, WebAssembly | (md 형식) | 2021-10-28 |\n\nNotion API를 사용했을 때, 프론트엔드에서는 글 내용을 API 통신으로 json으로 가져오고 렌더링하면 됐습니다. 하지만 지금은 md 형식을 해석하고 렌더링해야 하므로 이 부분을 수정하였습니다. md 렌더링을 위해 [react-markdown 모듈](https://github.com/remarkjs/react-markdown)을 사용했습니다.\n\n```tsx\n<ReactMarkdown\n    className=\"prose dark:prose-invert max-w-[800px]\"\n    children={data.Content}\n    rehypePlugins={[rehypeRaw]}\n    remarkPlugins={[remarkGfm]}\n    components={{\n        code({ children, className, inline }) {\n            return inline ? (\n                <code className=\"p-1 rounded bg-[#f2f2f2] font-mono dark:bg-[#0f081c]\">{children}</code>\n            ) : (\n                <Code code={children[0]?.toString()} language={className} />\n            );\n        },\n    }}\n/>\n```\n\nDB를 만들고 프론트엔드 부분도 처리했으니 이제 서버 쪽을 보겠습니다. DynamoDB에 저장되어 있는 데이터를 가져오기 위해 Lambda를 이용합니다. Lambda는 AWS에서 제공하는 서버리스 컴퓨팅 서비스입니다. 일반적인 서버를 구축하기 위해서는 언어 런타임 프로그램, Apache, 서버 프레임워크 같은 도구들이 필요합니다. 하지만 Lambda를 이용하면 위와 같은 서버 설정 없이 애플리케이션 코드만 있으면 서버 응답을 받을 수 있습니다. 마치 로컬 환경에서 함수를 실행하듯이 말이죠. Lambda는 여러 언어를 지원하는데 저는 Go 언어를 선택했습니다.\n\nLambda를 통해 구현하고 싶은 것은 전체 글 조회와 특정 글 조회 기능입니다. 설명탕 글 데이터는 DynamoDB에 저장되어있으니 Lambda와 DynamoDB 간의 통신이 필요합니다. 이를 위해 [aws-sdk-go-v2](https://github.com/aws/aws-sdk-go-v2) 패키지를 이용했으며 URL query에 따라 글 데이터를 가져오도록 구현했습니다. 전체적인 코드 구현은 [GitHub](https://github.com/redundant4u/SeolMyeongTang-Server)에서 찾아볼 수 있습니다.\n\n```go\nfunc getPostsFromDB(ctx context.Context) ([]postWithoutContent, error) {\n\tres, err := db.Query(ctx, &dynamodb.QueryInput{\n\t\tTableName:              aws.String(tableName),\n\t\tKeyConditionExpression: aws.String(\"#PK = :PK\"),\n\t\tExpressionAttributeNames: map[string]string{\n\t\t\t\"#PK\": \"PK\",\n\t\t},\n\t\tExpressionAttributeValues: map[string]types.AttributeValue{\n\t\t\t\":PK\": &types.AttributeValueMemberS{Value: pk},\n\t\t},\n\t})\n\terrCheck(\"Couldn't query\", err)\n\n\tvar posts []postWithoutContent\n\terr = attributevalue.UnmarshalListOfMaps(res.Items, &posts)\n\terrCheck(\"Couldn't unmarshal query response\", err)\n\n\treturn posts, nil\n}\n```\n\n작성한 Go 코드를 Lambda에서 실행하기 위해서 `main()`에 `lambda.start(HANDLER_FUNC)` 함수를 추가했습니다. 그 후 Lambda에 Go 빌드물을 올리면 됩니다.\n\n```go\npackage main\n\nimport (\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\nfunc main() {\n\tlambda.Start(router)\n}\n```\n\nLambda에 Go 빌드물을 올리는 방법은 다양합니다. Go 빌드 후 나온 빌드물을 zip 압축하여 Lambda에 올리는 방법도 있고 S3를 통해서 올려도 되고 AWS CLI를 이용해도 되고 스크립트를 이용해도 됩니다. 이상적인 방법은 CICD에 스크립트를 활용하여 자동배포를 구축하는 것이 좋겠으나 잦은 서버 배포가 필요 없을 거라 생각되어 빌드물을 압축 후 Lambda에 올리는 방법을 선택했습니다.\n\n작성한 Lambda는 API Gateway와 연동할거라 query, params와 같은 사용자의 request를 받기 위해 `APIGatewayProxyRequest` 인자를 추가합니다. 또한 통신하려는 URL에 대하여 cors 허용을 하기 위해 header에 cors 관련 내용도 적어줘야합니다.\n\n```go\nfunc getPosts(ctx context.Context) (events.APIGatewayProxyResponse, error) {\n\tposts, err := getPostsFromDB(ctx)\n\terrCheck(\"Couldn't get posts from db\", err)\n\n\tbody, err := json.Marshal(posts)\n\terrCheck(\"Couldn't marshal\", err)\n\n\treturn events.APIGatewayProxyResponse{\n\t\tStatusCode: 200,\n\t\tHeaders: map[string]string{\n\t\t\t\"Access-Control-Allow-Origin\":  \"redundant4u.com\",\n\t\t\t\"Access-Control-Allow-Methods\": \"OPTIONS,GET\",\n\t\t\t\"Access-Control-Allow-Headers\": \"Content-Type\",\n\t\t\t\"Content-Type\":                 \"application/json\",\n\t\t},\n\t\tBody: string(body),\n\t}, nil\n}\n```\n\n코드를 모두 작성했다면 Go를 빌드 후 zip으로 압축하고 이를 Lambda에 올립니다. 주의할 점은 Lambda에 올릴 때 ‘런타임 설정’에서 핸들러 이름을 main으로 바꿔줘야 합니다. 빌드물을 올리면 Lambda에서 배포가 진행됩니다.\n\n```bash\nGOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o main .\nzip function.zip main\n```\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230502/4.png\" alt=\"Lambda 핸들러 이름 설정\" /><figcaption>Lambda 핸들러 이름 설정</figcaption></figure>\n\n다음으로는 API Gateway를 살펴보겠습니다. Lambda를 통해 서버 코드를 작성했지만 사용자가 직접적으로 Lambda와 통신하지 않습니다. 물론 Lambda와 직접적으로 통신하도록 구성할 수 있지만, API Gateway를 통해 RESTful API 생성, 인증 및 배포 관리, 다른 AWS 서비스와의 연동 등의 기능을 수행 할 수 있습니다. Lambda와 API Gateway를 연동하여 서비스를 보다 견고하게 만들어 보겠습니다.\n\nAPI Gateway 이름에서 알 수 있듯이 Nginx와 같이 서버 앞 단의 gateway 역할을 합니다. API Gateway는 외부로부터 들어온 요청을 EC2와 통신할지 Lambda와 통신할지 혹은 다른 서버와 통신할지 선택할 수 있습니다. 구체적인 API Gateway 구축 과정은 생략하겠습니다. 다만 API Gateway와 Lambda를 설정할 때 주의할 점은 ‘통합 요청’ 항목에서 ‘Lambda 프록시 통합 사용’을 활성화해줘야 Lambda 까지 요청이 넘어가게됩니다. 또한 통신하려는 URL에 대한 cors 허용을 해줘야합니다. Lambda와 API Gateway 두 서비스 모두 cors 관련 설정을 해줘야 클라이언트에 정상적으로 데이터를 보낼 수 있으니 주의해야합니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230502/5.png\" alt=\"Lambda 프록시 통합 사용 활성화\" /><figcaption>Lambda 프록시 통합 사용 활성화</figcaption></figure>\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230502/6.png\" alt=\"API Gateway cors 활성화\" /><figcaption>API Gateway cors 활성화</figcaption></figure>\n\nAPI Gateway 배포를 하게 되면 `ap-northeast-2.amazonaws.com/[STAGE_NAME]`으로 끝나는 URL을 받게 됩니다. 이 URL을 통해 API Gateway와 통신을 해도 되지만, ‘사용자 지정 도메인 이름’을 통해 설명탕 서브 도메인을 부여했습니다. 참고로 네임서버는 [namecheap](https://www.namecheap.com)을 이용했고 도메인과 서브도메인에 대한 SSL 인증은 기존의 letsencrypt에서 AWS의 Certificate Manager로 관리하도록 했습니다.\n\n이상으로, Notion API를 제거하고 md 형식을 렌더링하기 위해 DynamoDB 설계와 이에 따른 프론트엔드 코드를 수정하였습니다. 또한 Lambda와 API Gateway를 통해 DynamoDB와 통신하는 백엔드를 배포하였습니다. 이제 마지막으로 남은 부분은 프론트엔드 배포입니다. 다음 글을 통해 S3와 CloudFront를 통해 프론트 배포를 진행하도록 하겠습니다."
          },
          "CreatedAt": {
            "S": "2023-05-20"
          },
          "Title": {
            "S": "싱글벙글 서버리스 이전 삽질기(w. Lambda)"
          }
        }
      }
    },
    {
      "PutRequest": {
        "Item": {
          "PK": {
            "S": "post"
          },
          "SK": {
            "S": "serverless_offline"
          },
          "Content": {
            "S": "서버리스가 AWS EC2와 같은 서버보다 좋을 수 있습니다. 트래픽이 많이 일어나지 않는 작은 서비스라면 24시간 돌아가는 서버 환경보다 서버리스 환경이 더 경제적입니다. [설명탕 홈페이지를 EC2에서 서버리스 환경으로 옮기면서](https://redundant4u.com/post/serverless_lambda) 인프라 내부적으로 많은 변화가 있었습니다. 현재까지 설명탕을 서버리스 환경으로 운영하는데 큰 불편함이 없습니다. 하지만 설명탕 서비스를 장기적으로 운영하기 위해서는 개발 환경이 필요했습니다. 서버 배포하기 전에 충분한 테스트를 하기 위해서는 개발 환경이 필요합니다. 서버리스가 단어 그 의미처럼 서버가 없다는 개념이라 개발 환경을 어떻게 구성해야 할지 난감했습니다. AWS에서 개발용 서버리스(Lambda, API Gateway)와 DynamoDB를 새롭게 만들어도 되지만, 로컬(혹은 오프라인)에 개발 환경을 만들고 싶었습니다.\n\n서버리스가 아닌 기존의 서버 방식이었다면 로컬에 백엔드, DB 두 개의 컨테이너를 생성하여 개발 환경을 만들었을 텐데 서버리스 환경은 어떻게 기존과 유사하게 개발 환경을 구축해야 할지 감이 오지 않았습니다. 서버리스 로컬 개발 환경을 조사를 하다 [serverless-offline 플러그인](https://www.serverless.com/plugins/serverless-offline)을 알게 되었습니다. serverless-offline 플러그인을 통해 서버리스 로컬 개발 환경을 만들고 더 나아가 [Flutter의 hot reload](https://docs.flutter.dev/tools/hot-reload)나 [NextJS의 fast refresh 기능](https://nextjs.org/docs/architecture/fast-refresh) 처럼 코드를 수정하면 즉각적으로 수정 사항을 반영하는 환경을 만들어보겠습니다.\n\n서버리스 로컬 개발 환경을 만들기 위해 다음과 같은 순서로 진행됩니다.\n\n1. serverless, serverless-offline 설치\n2. `serverless.yml` 정의\n3. 로컬 DynamoDB 구축\n4. 로컬 DynamoDB와 Golang 연결\n5. air 모듈을 통한 fast refresh 구성\n\nserverless-offline 플러그인은 로컬에 AWS의 Lambda, API Gateway 환경을 만들어주는 [serverless Node 모듈](https://www.serverless.com/)의 플러그인입니다. serverless 모듈은 AWS Lambda와 같은 서버리스 환경을 쉽게 배포할 수 있도록 도와주는 프레임워크입니다. 즉, serverless-offline 플러그인을 이용하여 로컬에 서버리스 환경을 만들 수 있습니다. 또한 로컬 환경에서 마음껏 테스트한 다음 serverless 모듈을 통해 AWS에 배포를 할 수 있습니다.\n\nserverless-offline 플러그인을 사용하기 위해서는 serverless 모듈을 설치해야합니다. `npm` 혹은 `yarn`을 통해서 serverless 모듈을 편하게 호출하기 위해 전역으로 설치합니다.\n\n```bash\nnpm i -g serverless\nyarn global add serverless\n```\n\n그 다음으로 serverless 프로젝트를 생성합니다. 저는 Golang을 사용한 Lambda 환경이 필요하여 aws-go 템플릿을 선택했습니다. 선택 가능한 템플릿 목록은 [이 링크](https://www.serverless.com/framework/docs/providers/aws/cli-reference/create#available-templates)를 참고해주세요.\n\n```bash\nserverless create -t aws-go -p [PATH]\n```\n\n생성된 프로젝트를 살펴보면 `serverless.yml` 파일을 찾을 수 있습니다. `serverless.yml` 파일은 AWS CloudFormation과 유사한 문법으로 이루어져 있습니다. Lambda, API Gateway를 콘솔에서 설정하듯이 함수와 이벤트에 대해 정의할 수 있습니다. `serverless.yml`에 쓰이는 key property 목록은 [이 링크](https://www.serverless.com/framework/docs/providers/aws/guide/serverless.yml)를 참고해주세요. 제가 쓸 key property는 `service`, `frameworkVersion`, `provider`, `functions`, `custom`, `plugins` 총 6개입니다. 간단하게 하나씩 정의한 key property에 대해 알아보겠습니다.\n\n```yaml\nservice: local\n\nframeworkVersion: '3'\n\nprovider:\n    name: aws\n    runtime: go1.x\n    region: ap-northeast-2\n    environment:\n        ENV: local\n        AWS_REGION: ap-notheast-2\n        DYNAMODB_TABLE: TEST_TABLE\n        DYNAMODB_PK: TEST_PK\n\nfunctions:\n    main:\n        handler: main\n        events:\n            - http:\n                  path: /post\n                  method: get\n            - http:\n                  path: /post/{postId}\n                  method: get\n\ncustom:\n    serverless-offline:\n        useDocker: true\n        noTimeout: true\n        reloadHandler: true\n\nplugins:\n    - serverless-offline\n```\n\n`provider`는 실행할 환경을 정의합니다. AWS Lambda 콘솔에서 설정할 수 있는 항목과 유사하게 `runtime`, `environment`, `memorySize`, `timeout`와 같은 항목을 설정할 수 있습니다.\n\n`functions`는 Lambda 함수와 이벤트를 정의합니다. 실행할 `handler` 이름과 Lambda 함수를 실행할 이벤트(API Gateway HTTP API 혹은 REST API)를 지정할 수 있습니다.\n\n`custom`은 serverless 모듈의 플러그인에 적용할 CLI 옵션을 정의할 수 있습니다. serverless-offline 플러그인을 사용할 것이므로 serverless-offline 플러그인에 적용할 CLI 옵션을 넣어줍니다. serverless-offline 플러그인에 적용할 수 있는 CLI 옵션 목록은 [이 링크](https://github.com/dherault/serverless-offline#usage-and-command-line-options)를 참고해주세요. 제가 설정한 옵션의 설명은 아래에서 설명하도록 하겠습니다.\n\n마지막으로 `plugins`에는 serverless 모듈과 연동할 플러그인을 정의할 수 있습니다. serveless-offline 플러그인을 쓸 거라 serverless-offline 모듈을 설치하고 `serverless.yml` 파일에 `plugins` 항목에 정의해 줍니다.\n\n```bash\nnpm i -D serverless-offline\nyarn add -D serverless-offline\n```\n\n`serverless.yml`에 설정을 완료했다면 아래의 명령어로 serverless 모듈을 실행할 수 있습니다.\n\n```bash\nserverless offline start\n```\n\nserverless-offline 플러그인을 통해 서버리스 로컬 환경을 만드는 방법은 2가지가 있습니다. 프로세스를 통해 실행하거나(`useChildProcesses` 옵션) 컨테이너를 통해 실행하는 방법(`useDocker` 옵션)이 있습니다. 프로세스를 통해 서버리스 로컬 환경을 구성해도 되지만 serverless-offline 플러그인의 버그인지 2번 이상 요청을 보내면 handler 쪽에 이상이 생겨 환경 구성에 어려움이 있었습니다. 따라서 프로세스가 아닌 컨테이너를 통해 환경을 구성했습니다.\n\n개발 환경이라 timeout 조건은 없앴고 나중에 hot reload와 같은 기능을 쓰기 위해 매 요청마다 새로운 handler를 만드는 `reloadHandler` 옵션을 추가했습니다. `useDocker`, `reloadHandler` 옵션을 주면 매 요청마다 handler(Golang 빌드물, 위 예시에서는 main)를 가져와 새로운 컨테이너로 만들고 실행하는 모습을 볼 수 있습니다.\n\n하지만 `reloadHandler` 옵션을 주면 요청마다 새로운 컨테이너를 만들므로 cold start 처럼 응답이 다소 느립니다. 프론트엔드 쪽을 집중적으로 테스트하고 싶거나 잦은 서버리스 코드 변경이 없다면 이 옵션을 해제하는 것이 좋습니다.\n\n<figure><img src=\"https://seolmyeongtang.s3.ap-northeast-2.amazonaws.com/230604/1.jpg\" alt=\"요청을 보내면 서버리스 컨테이너가 생성이 된다\" /><figcaption>요청을 보내면 서버리스 컨테이너가 생성이 된다</figcaption></figure>\n\n---\n\n`reloadHandler` 옵션을 활성화하면 요청마다 컨테이너가 생기니 로컬 자원을 심하게 낭비하지 않는가에 대한 의문이 들 수 있겠습니다. 저 또한 같은 생각을 했습니다. severless-offline 플러그인의 기능인지 lambda 도커 이미지의 설정인지 일정 시간이 지나면 자동으로 컨테이너를 삭제하여 심각한 자원 소모는 없을 거라 판단했습니다. 조금 아쉬웠던 점은 serverless-offline 플러그인은 Golang 이미지를 2년 전에 만들었던 [lambci/lambda:go1.x 이미지](https://hub.docker.com/r/lambci/lambda/)를 사용합니다. [Amazon에서 제공하는 정식적인 이미지](https://hub.docker.com/r/amazon/aws-lambda-go)가 존재하고 관리도 꾸준히 하고있어서 이 이미지를 썼으면 어땠을까 하는 점이 있었습니다.\n\n---\n\n위 과정으로 서버리스 로컬 환경을 만들었지만 DB 환경도 필요합니다. [serverless-dynamodb-local 플러그인](https://www.serverless.com/plugins/serverless-dynamodb-local)을 통해서 로컬 DynamoDB 환경을 만들 수 있지만 따로 컨테이너로 관리하는 방식을 선택했습니다. 로컬 DynamoDB 환경을 위해 [AWS docs](https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/DynamoDBLocal.DownloadingAndRunning.html)를 참고하여 다음과 같이 `docker-compose.yml`를 작성했습니다.\n\n```yaml\nversion: '3.5'\n\nservices:\n    dynamodb:\n        image: 'amazon/dynamodb-local:1.21.0'\n        container_name: dynamodb\n        working_dir: /home/dynamodblocal\n        volumes:\n            - './local/docker/dynamodb/data:/home/dynamodblocal/data'\n        ports:\n            - 8000:8000\n        environment:\n            - AWS_REGION=ap-northeast-2\n            - AWS_ACCESS_KEY_ID=local\n            - AWS_SECRET_ACCESS_KEY=local\n            - AWS_SESSION_TOKEN=local\n        command: '-jar DynamoDBLocal.jar -sharedDb -dbPath ./data'\n```\n\nDynamoDB에 테스트할 데이터가 필요하니 AWS CLI를 활용하여 테이블을 만들고 데이터도 넣어줍니다.\n\n```bash\naws dynamodb create-table --table-name TEST_TABLE \\\n  --attribute-definitions \\\n    AttributeName=TEST_PK,AttributeType=S \\\n    AttributeName=TEST_SK,AttributeType=S \\\n  --key-schema \\\n    AttributeName=PK,KeyType=HASH \\\n    AttributeName=SK,KeyType=RANGE \\\n  --provisioned-throughput ReadCapacityUnits=10,WriteCapacityUnits=10 \\\n  --endpoint-url http://localhost:8000\n\naws dynamodb batch-write-item \\\n  --request-items file://seed.json \\\n  --endpoint-url http://localhost:8000\n\ncat seed.json\n{\n  \"TEST_TABLE\": [\n    {\n      \"PutRequest\": {\n        \"Item\": {\n          \"TEST_PK\": {\n            \"S\": \"post\"\n          },\n          \"TEST_SK\": {\n            \"S\": \"test1\"\n          },\n          \"Content\": {\n            \"S\": \"hello\"\n          },\n          \"CreatedAt\": {\n            \"S\": \"2023-05-01\"\n          },\n          \"Title\": {\n            \"S\": \"test1\"\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\n로컬 DynamoDB와 연결하기 위해 Golang 코드도 다음과 같이 수정이 필요합니다. 이 때 주의할 점은 DynamoDB를 컨테이너로 실행하고 있으니 주소를 MacOS 기준으로 `localhost`가 아닌 `host.docker.internal` 주소로 적어야합니다.\n\n```go\nfunc init() {\n\tvar cfg aws.Config\n\tvar err error\n\n\tif env == \"local\" {\n\t\tcustomResolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) {\n\t\t\tif service == dynamodb.ServiceID {\n\t\t\t\treturn aws.Endpoint{\n\t\t\t\t\tURL: \"http://host.docker.internal:8000\",\n\t\t\t\t}, nil\n\t\t\t}\n\t\t\t// returning EndpointNotFoundError will allow the service to fallback to it's default resolution\n\t\t\treturn aws.Endpoint{}, &aws.EndpointNotFoundError{}\n\t\t})\n\n\t\tcredentials := credentials.StaticCredentialsProvider{\n\t\t\tValue: aws.Credentials{\n\t\t\t\tAccessKeyID:     \"local\",\n\t\t\t\tSecretAccessKey: \"local\",\n\t\t\t\tSessionToken:    \"local\",\n\t\t\t},\n\t\t}\n\n\t\tregion = \"ap-northeast-2\"\n\t\ttableName = \"TEST_TABLE\"\n\t\tpk = \"TEST_PK\"\n\n\t\tcfg, err = config.LoadDefaultConfig(\n\t\t\tcontext.TODO(),\n\t\t\tconfig.WithRegion(region),\n\t\t\tconfig.WithEndpointResolverWithOptions(customResolver),\n\t\t\tconfig.WithCredentialsProvider(credentials),\n\t\t)\n\t} else {\n\t\tcfg, err = config.LoadDefaultConfig(context.TODO(), config.WithRegion(region))\n\t}\n\terrCheck(\"Unable to load Dynamodb config\", err)\n\n\tdb = *dynamodb.NewFromConfig(cfg)\n}\n```\n\n야호! serverless-offline 모듈과 DynamoDB 컨테이너를 통해 로컬 서버리스 환경을 만들었습니다. 위의 구성으로 테스트해 보니 서버리스 로컬 개발 환경으로 만족스러웠습니다. 하지만 하나의 아쉬움이 있었습니다. 서버리스 코드를 수정하고 반영된 서버리스 상태를 보기 위해서는 몇 가지의 과정을 수동으로 처리해 줘야 했습니다.\n\n1. 서버리스 코드 수정\n2. 빌드\n3. serverless-offline 중지\n4. serverless-offline 시작\n\n위 과정을 한두 번 하는 건 괜찮지만, 계속된 수동 작업을 반복하면서 이 과정들을 자동화하고 싶은 마음이 굴뚝같았습니다. 따라서 Flutter의 hot realod나 NextJS의 fast refresh와 유사한 효과를 내기 위해 추가적인 작업을 진행했습니다.\n\n새로운 서버리스 코드가 추가되면 자동으로 빌드 작업을 하기 위해 [air 모듈](https://github.com/cosmtrek/air)을 사용했습니다. air 모듈은 실시간으로 Golang 코드 변경을 감지하고 감지 됐을 때 어떤 동작을 하게 할 건지에 대한 정의할 수 있습니다. air 모듈을 사용하기 위해 자동 빌드를 적용하고 싶은 Golang 프로젝트에서 air 모듈을 설치하고 초기화를 진행합니다.\n\n```bash\ngo install github.com/cosmtrek/air@latest\nair init\n```\n\n`air init` 명령어로 초기화를 하면 `.air.toml` 설정 파일이 생성됩니다. 저희는 `.air.toml` 내용에서 [build]의 `cmd` 부분을 수정해주면 됩니다. 이 부분을 수정하면 Golang 코드를 수정했을 때 어떤 명령어를 실행할지에 대한 수정을 할 수 있습니다. 전체적인 `.air.toml`에 대해서는 [이 링크](https://github.com/cosmtrek/air/blob/master/air_example.toml)를 참고해주세요.\n\n```toml\n[build]\ncmd = \"GOOS=linux CGO_ENABLED=0 go build -o local/main .\"\n```\n\n참고로 제 프로젝트 디렉터리 구조는 다음과 같습니다.\n\n```bash\n> tree -a -L 2 .\n.\n├── .air.toml\n├── main.go\n├── docker # 서버리스 로컬 개발 환경을 위한 도커 모음\n│   ├── dynamodb\n│   └── golang\n├── internal # 서버리스 Golang 코드 모음\n└── local # serverless 모듈을 통해 서버리스 개발 환경을 위한 코드 모음\n```\n\nair 모듈의 도움으로 코드 수정할 때마다 새로운 Golang 빌드물을 만들 수 있게 되었습니다. 마지막으로 고려해야 할 점이 있습니다. 저희는 서버리스 로컬 개발 환경을 컨테이너로 돌립니다. 따라서 컨테이너에 이 새로운 빌드물을 적용해야 합니다. 이것을 가능하게 하기 위해 볼륨을 엮는 방법 등을 시도해보았습니다만, 이런 저런 삽질 끝에 앞서 말한 `reloadHandler` 옵션을 활성화하여 요청마다 새로운 컨테이너를 만들어 적용하는 방법을 선택했습니다. 다만 이 방법은 아무래도 새 컨테이너를 만드는 시간이 필요하니 저처럼 성질 급한 개발자한테는 조금은 답답한 속도일 수 있겠습니다.\n\n서버리스 로컬 개발 환경 구축을 위한 과정을 하나의 스크립트를 통해 실행할 수 있도록 만들었습니다. 로컬 개발 환경을 원할 때마다 스크립트를 실행하여 개발 환경을 만들도록 구성했습니다.\n\n```bash\n#!/bin/sh\n\n### Run DynamoDB container\ndocker compose -p dynamodb-local up -d\n\n### Enable golang build automation\nair &\n\n### Run serverless\ncd local\nserverless offline start &\n\n### Wait until the processes are finished\ntrap \"kill $!\" INT\nwait $!\n\n### Clean up\ndocker compose -p dynamodb-local down\ndocker ps -a --filter \"status=exited\" --filter \"ancestor=lambci/lambda:go1.x\" -q | xargs -r docker rm\n```\n\n최종적으로 serverless 모듈, serverless-offline 플러그인, air 모듈, 컨테이너를 통해 서버리스 로컬 개발 환경을 만들었습니다. 덕분에 로컬에서 편하게 프론트엔드, 백엔드 테스트할 수 있게 되었습니다. 서버리스 로컬 개발 환경에 대한 코드는 [GitHub](https://github.com/redundant4u/SeolMyeongTang-Server)에서 볼 수 있으니 참고하시면 좋을 거 같습니다. 참, 그리고 serverless 모듈에 배포 기능도 있어서 이 기능 또한 활용하면 좋을 거 같습니다."
          },
          "CreatedAt": {
            "S": "2023-06-04"
          },
          "Title": {
            "S": "serverless-offline 모듈을 통한 서버리스 로컬 개발 환경 만들기"
          }
        }
      }
    }
  ]
}
